#pragma kernel CSMain
#pragma kernel HandleCollisions

struct Particle
{
    float3 position;
    float3 velocity;
    float density;
    float pressure;
};

struct Triangle
{
    float3 v0;
    float3 v1;
    float3 v2;
};

RWStructuredBuffer<Particle> particles;
StructuredBuffer<Triangle> triangles;
StructuredBuffer<float3> nodeCenters;
StructuredBuffer<float3> nodeSizes;
StructuredBuffer<int> nodeObjectCounts;
StructuredBuffer<int> nodeObjects;

int particleCount;
int triangleCount;
float restDensity;
float stiffness;
float viscosity;
float particleMass;
float gravity;
float3 gravityDirection;
float3 windForce;
float windStrength;
float deltaTime;
float smoothingRadius;
float3 boxMin;
float3 boxMax;

float Poly6Kernel(float r, float h)
{
    if (r > h) return 0.0;
    float h2 = h * h;
    float r2 = r * r;
    float hr = h2 - r2;
    return (315.0 / (64.0 * 3.141592653589793 * pow(h, 9.0))) * pow(hr, 3.0);
}

float3 SpikyKernelGradient(float3 r, float h)
{
    float rLength = length(r);
    if (rLength > h) return float3(0, 0, 0);
    float hr = h - rLength;
    float coefficient = (45.0 / (3.141592653589793 * pow(h, 6.0))) * pow(hr, 2.0);
    return coefficient * (r / rLength);
}

float ViscosityKernelLaplacian(float r, float h)
{
    if (r > h) return 0.0;
    return (45.0 / (3.141592653589793 * pow(h, 6.0))) * (h - r);
}

[numthreads(256, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= particleCount) return;

    Particle p = particles[id.x];

    // Compute density
    p.density = 0.0;
    for (int i = 0; i < particleCount; ++i)
    {
        float distance = length(particles[i].position - p.position);
        if (distance < smoothingRadius)
        {
            float weight = Poly6Kernel(distance, smoothingRadius);
            p.density += particleMass * weight;
        }
    }
    p.pressure = stiffness * (p.density - restDensity);

    // Compute forces
    float3 totalForce = float3(0, 0, 0);
    float3 pressureForce = float3(0, 0, 0);
    float3 viscosityForce = float3(0, 0, 0);

    for (int i = 0; i < particleCount; ++i)
    {
        if (i == id.x) continue;

        float3 direction = particles[i].position - p.position;
        float distance = length(direction);

        if (distance < smoothingRadius)
        {
            float pressureTerm = (p.pressure + particles[i].pressure) / (2.0 * particles[i].density);
            pressureForce += -particleMass * pressureTerm * SpikyKernelGradient(direction, smoothingRadius);

            float3 velocityDifference = particles[i].velocity - p.velocity;
            viscosityForce += viscosity * particleMass * (velocityDifference / particles[i].density) * ViscosityKernelLaplacian(distance, smoothingRadius);
        }
    }
    float3 gravityForce = gravity * gravityDirection * particleMass;
    totalForce += pressureForce + viscosityForce + gravityForce;
    totalForce += windForce * windStrength;

    p.velocity += deltaTime * totalForce * 0.0002;
    p.position += deltaTime * p.velocity;

    // Boundary conditions
    if (p.position.x < boxMin.x) { p.position.x = boxMin.x; p.velocity.x = -p.velocity.x; }
    if (p.position.x > boxMax.x) { p.position.x = boxMax.x; p.velocity.x = -p.velocity.x; }
    if (p.position.y < boxMin.y) { p.position.y = boxMin.y; p.velocity.y = -p.velocity.y; }
    if (p.position.y > boxMax.y) { p.position.y = boxMax.y; p.velocity.y = -p.velocity.y; }
    if (p.position.z < boxMin.z) { p.position.z = boxMin.z; p.velocity.z = -p.velocity.z; }
    if (p.position.z > boxMax.z) { p.position.z = boxMax.z; p.velocity.z = -p.velocity.z; }

    particles[id.x] = p;
}

bool IsPointInTriangle(float3 p, float3 a, float3 b, float3 c)
{
    // Calculate vectors
    float3 v0 = b - a;
    float3 v1 = c - b;
    float3 v2 = a - c;

    // Calculate normal vectors for each edge
    float3 n0 = cross(v0, p - a);
    float3 n1 = cross(v1, p - b);
    float3 n2 = cross(v2, p - c);

    // Check if the point lies on the same side of each edge
    return dot(n0, n1) >= 0 && dot(n1, n2) >= 0 && dot(n2, n0) >= 0;
}


[numthreads(256, 1, 1)]
void HandleCollisions(uint id : SV_DispatchThreadID)
{
    if (id.x >= particleCount) return;

    Particle p = particles[id.x];

    for (int i = 0; i < triangleCount; i++)
    {
        Triangle t = triangles[i];

       
        if (IsPointInTriangle(p.position, t.v0, t.v1, t.v2))
        {
            float3 normal = normalize(cross(t.v1 - t.v0, t.v2 - t.v0));
            p.velocity = reflect(p.velocity, normal);
            p.position += normal * 0.01f;

          
            break;
        }
    }

    particles[id.x] = p;
}
